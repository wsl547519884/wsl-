### 第一周正式课–课后作业（3）

#### 1.
- obj {...}
- widow {...}

#### 2.
- undefined
- 'language'

#### 3.
- window

#### 4.
- 24

#### 5.
- 12

#### 6.
- 22
- 23
- 65,30

#### 7.
- 不能实现
- 点击任意一个都会输出5
- 把for里面的var改成let，用var定义的是属于全局下的i，那时的i已经为5了，而let会形成父作用域，把每一次的循环都都当作一个私有的子作用域，每一次循环的i都是各个子作用域中的私有变量，所以可以达到我们想要的效果

#### 8.
- 保护作用
    - 团队开发中可以把自己的代码，可以放到闭包中保护起来，防止和别人的代码发生冲突
    - 封装一个插件时，为了防止调用时，和原代码冲突，可以放到闭包中，防止冲突
- 存储作用
    - 可以利用闭包，形成一个不被销毁的执行上下文，把需用用到的值保存起来
- 优点：可以用来保护和存储
- 缺点：执行上下文不被释放，占内存，消耗性能

#### 9.
- 相对于语法来说let比var更加严谨
- var存在变量提升，let没有
- let不允许重复声明，是在代码执行之前进行词法解析检验是否声明过，声明过则直接会报错，不再执行代码，var允许重复声明，但是浏览器只会执行一次，不会报错
- var声明即是全局变量，也会在GO中创建一个属性，而let只是全局变量，和GO没关系
- let可以防止typeof的bug，一个没有声明过的变量，会显示undefined，应该报错才对，可以把let在下面声明，因为let不能再声明之前使用变量

#### 10.
把var改成let
```
for (let i = 0; i < 10; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}
```

#### 11.
- 输出结果为  20 20；因为自执行函数执行时，b是找的EC(G)中的b，因为它本身没有私有变量b，把EC(G)中的b赋值成了20，所以都输出20
- 可以在自执行函数中把b声明一下，使b为自执行函数的私有变量，就不会更改EC(G)中的b了，输出结果就为20 10
```
var b = 10;
(function b() {
    let b = 20;
    console.log(b);
})();
console.log(b);
```